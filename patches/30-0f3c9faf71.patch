commit 0f3c9faf712232dcd27689ce63d364cf3391812a
Author: Kevin Dangoor <kid@blazingthings.com>
Date:   Mon Nov 8 15:07:21 2010 -0500

    bring in require.js with plugins (to be able to load text)

diff --git a/scripts/require.js b/scripts/require.js
index 98dc053..596909b 100644
--- a/scripts/require.js
+++ b/scripts/require.js
@@ -1700,3 +1700,781 @@ var require, define;
     }
 }());
 
+/**
+ * @license RequireJS i18n Copyright (c) 2010, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+/*jslint regexp: false, nomen: false, plusplus: false */
+/*global require: false, navigator: false */
+
+
+/**
+ * This plugin handles i18n! prefixed modules. It does the following:
+ *
+ * 1) A regular module can have a dependency on an i18n bundle, but the regular
+ * module does not want to specify what locale to load. So it just specifies
+ * the top-level bundle, like "i18n!nls/colors".
+ *
+ * This plugin will load the i18n bundle at nls/colors, see that it is a root/master
+ * bundle since it does not have a locale in its name. It will then try to find
+ * the best match locale available in that master bundle, then request all the
+ * locale pieces for that best match locale. For instance, if the locale is "en-us",
+ * then the plugin will ask for the "en-us", "en" and "root" bundles to be loaded
+ * (but only if they are specified on the master bundle).
+ *
+ * Once all the bundles for the locale pieces load, then it mixes in all those
+ * locale pieces into each other, then finally sets the context.defined value
+ * for the nls/colors bundle to be that mixed in locale.
+ *
+ * 2) A regular module specifies a specific locale to load. For instance,
+ * i18n!nls/fr-fr/colors. In this case, the plugin needs to load the master bundle
+ * first, at nls/colors, then figure out what the best match locale is for fr-fr,
+ * since maybe only fr or just root is defined for that locale. Once that best
+ * fit is found, all of its locale pieces need to have their bundles loaded.
+ *
+ * Once all the bundles for the locale pieces load, then it mixes in all those
+ * locale pieces into each other, then finally sets the context.defined value
+ * for the nls/fr-fr/colors bundle to be that mixed in locale.
+ */
+(function () {
+    //regexp for reconstructing the master bundle name from parts of the regexp match
+    //nlsRegExp.exec("foo/bar/baz/nls/en-ca/foo") gives:
+    //["foo/bar/baz/nls/en-ca/foo", "foo/bar/baz/nls/", "/", "/", "en-ca", "foo"]
+    //nlsRegExp.exec("foo/bar/baz/nls/foo") gives:
+    //["foo/bar/baz/nls/foo", "foo/bar/baz/nls/", "/", "/", "foo", ""]
+    //so, if match[5] is blank, it means this is the top bundle definition.
+    var nlsRegExp = /(^.*(^|\/)nls(\/|$))([^\/]*)\/?([^\/]*)/,
+        empty = {};
+
+    function getWaiting(name, context) {
+        var nlswAry = context.nlsWaiting;
+        return nlswAry[name] ||
+               //Push a new waiting object on the nlsWaiting array, but also put
+               //a shortcut lookup by name to the object on the array.
+               (nlswAry[name] = nlswAry[(nlswAry.push({ _name: name}) - 1)]);
+    }
+
+    /**
+     * Makes sure all the locale pieces are loaded, and finds the best match
+     * for the requested locale.
+     */
+    function resolveLocale(masterName, bundle, locale, context) {
+        //Break apart the locale to get the parts.
+        var i, parts, toLoad, nlsw, loc, val, bestLoc = "root";
+
+        parts = locale.split("-");
+
+        //Now see what bundles exist for each country/locale.
+        //Want to walk up the chain, so if locale is en-us-foo,
+        //look for en-us-foo, en-us, en, then root.
+        toLoad = [];
+
+        nlsw = getWaiting(masterName, context);
+
+        for (i = parts.length; i > -1; i--) {
+            loc = i ? parts.slice(0, i).join("-") : "root";
+            val = bundle[loc];
+            if (val) {
+                //Store which bundle to use for the default bundle definition.
+                if (locale === context.config.locale && !nlsw._match) {
+                    nlsw._match = loc;
+                }
+
+                //Store the best match for the target locale
+                if (bestLoc === "root") {
+                    bestLoc = loc;
+                }
+
+                //Track that the locale needs to be resolved with its parts.
+                //Mark what locale should be used when resolving.
+                nlsw[loc] = loc;
+
+                //If locale value is true, it means it is a resource that
+                //needs to be loaded. Track it to load if it has not already
+                //been asked for.
+                if (val === true) {
+                    //split off the bundl name from master name and insert the
+                    //locale before the bundle name. So, if masterName is
+                    //some/path/nls/colors, then the locale fr-fr's bundle name should
+                    //be some/path/nls/fr-fr/colors
+                    val = masterName.split("/");
+                    val.splice(-1, 0, loc);
+                    val = val.join("/");
+
+                    if (!context.specified[val] && !(val in context.loaded) && !context.defined[val]) {
+                        context.defPlugin[val] = 'i18n';
+                        toLoad.push(val);
+                    }
+                }
+            }
+        }
+
+        //If locale was not an exact match, store the closest match for it.
+        if (bestLoc !== locale) {
+            if (context.defined[bestLoc]) {
+                //Already got it. Easy peasy lemon squeezy.
+                context.defined[locale] = context.defined[bestLoc];
+            } else {
+                //Need to wait for things to load then define it.
+                nlsw[locale] = bestLoc;
+            }
+        }
+
+        //Load any bundles that are still needed.
+        if (toLoad.length) {
+            require(toLoad, context.contextName);
+        }
+    }
+
+    require.plugin({
+        prefix: "i18n",
+
+        /**
+         * This callback is prefix-specific, only gets called for this prefix
+         */
+        require: function (name, deps, callback, context) {
+            var i, match, nlsw, bundle, master, toLoad, obj = context.defined[name];
+
+            //All i18n modules must match the nls module name structure.
+            match = nlsRegExp.exec(name);
+            //If match[5] is blank, it means this is the top bundle definition,
+            //so it does not have to be handled. Only deal with ones that have a locale
+            //(a match[4] value but no match[5])
+            if (match[5]) {
+                master = match[1] + match[5];
+
+                //Track what locale bundle need to be generated once all the modules load.
+                nlsw = getWaiting(master, context);
+                nlsw[match[4]] = match[4];
+
+                bundle = context.nls[master];
+                if (!bundle) {
+                    //No master bundle yet, ask for it.
+                    context.defPlugin[master] = 'i18n';
+                    require([master], context.contextName);
+                    bundle = context.nls[master] = {};
+                }
+                //For nls modules, the callback is just a regular object,
+                //so save it off in the bundle now.
+                bundle[match[4]] = callback;
+            } else {
+                //Integrate bundle into the nls area.
+                bundle = context.nls[name];
+                if (bundle) {
+                    //A specific locale already started the bundle object.
+                    //Do a mixin (which will not overwrite the locale property
+                    //on the bundle that has the previously loaded locale's info)
+                    require.mixin(bundle, obj);
+                } else {
+                    bundle = context.nls[name] = obj;
+                }
+                context.nlsRootLoaded[name] = true;
+
+                //Make sure there are no locales waiting to be resolved.
+                toLoad = context.nlsToLoad[name];
+                if (toLoad) {
+                    delete context.nlsToLoad[name];
+                    for (i = 0; i < toLoad.length; i++) {
+                        resolveLocale(name, bundle, toLoad[i], context);
+                    }
+                }
+
+                resolveLocale(name, bundle, context.config.locale, context);
+            }
+        },
+
+        /**
+         * Called when a new context is defined. Use this to store
+         * context-specific info on it.
+         */
+        newContext: function (context) {
+            require.mixin(context, {
+                nlsWaiting: [],
+                nls: {},
+                nlsRootLoaded: {},
+                nlsToLoad: {}
+            });
+            if (!context.config.locale) {
+                context.config.locale = typeof navigator === "undefined" ? "root" :
+                        (navigator.language || navigator.userLanguage || "root").toLowerCase();
+            }
+        },
+
+        /**
+         * Called when a dependency needs to be loaded.
+         */
+        load: function (name, contextName) {
+            //Make sure the root bundle is loaded, to check if we can support
+            //loading the requested locale, or if a different one needs
+            //to be chosen.
+            var masterName, context = require.s.contexts[contextName], bundle,
+                match = nlsRegExp.exec(name), locale = match[4];
+
+            //If match[5] is blank, it means this is the top bundle definition,
+            //so it does not have to be handled. Only deal with ones that have a locale
+            //(a match[4] value but no match[5])
+            if (match[5]) {
+                //locale-specific bundle
+                masterName = match[1] + match[5];
+                bundle = context.nls[masterName];
+                if (context.nlsRootLoaded[masterName] && bundle) {
+                    resolveLocale(masterName, bundle, locale, context);
+                } else {
+                    //Store this locale to figure out after masterName is loaded and load masterName.
+                    (context.nlsToLoad[masterName] || (context.nlsToLoad[masterName] = [])).push(locale);
+                    context.defPlugin[masterName] = 'i18n';
+                    require([masterName], contextName);
+                }
+            } else {
+                //Top-level bundle. Just call regular load, if not already loaded
+                if (!context.nlsRootLoaded[name]) {
+                    context.defPlugin[name] = 'i18n';
+                    require.load(name, contextName);
+                }
+            }
+        },
+
+        /**
+         * Called when the dependencies of a module are checked.
+         */
+        checkDeps: function (name, deps, context) {
+            //i18n bundles are always defined as objects for their "dependencies",
+            //and that object is already processed in the require method, no need to
+            //do work in here.
+        },
+
+        /**
+         * Called to determine if a module is waiting to load.
+         */
+        isWaiting: function (context) {
+            return !!context.nlsWaiting.length;
+        },
+
+        /**
+         * Called when all modules have been loaded.
+         */
+        orderDeps: function (context) {
+            //Clear up state since further processing could
+            //add more things to fetch.
+            var i, j, master, msWaiting, bundle, parts, moduleSuffix, mixed,
+                modulePrefix, loc, defLoc, locPart, nlsWaiting = context.nlsWaiting,
+                bestFit;
+            context.nlsWaiting = [];
+            context.nlsToLoad = {};
+
+            //First, properly mix in any nls bundles waiting to happen.
+            for (i = 0; (msWaiting = nlsWaiting[i]); i++) {
+                //Each property is a master bundle name.
+                master = msWaiting._name;
+                bundle = context.nls[master];
+                defLoc = null;
+
+                //Create the module name parts from the master name. So, if master
+                //is foo/nls/bar, then the parts should be prefix: "foo/nls",
+                // suffix: "bar", and the final locale's module name will be foo/nls/locale/bar
+                parts = master.split("/");
+                modulePrefix = parts.slice(0, parts.length - 1).join("/");
+                moduleSuffix = parts[parts.length - 1];
+                //Cycle through the locale props on the waiting object and combine
+                //the locales together.
+                for (loc in msWaiting) {
+                    if (loc !== "_name" && !(loc in empty)) {
+                        if (loc === "_match") {
+                            //Found default locale to use for the top-level bundle name.
+                            defLoc = msWaiting[loc];
+                        
+                        } else if (msWaiting[loc] !== loc) {
+                            //A "best fit" locale, store it off to the end and handle
+                            //it at the end by just assigning the best fit value, since
+                            //after this for loop, the best fit locale will be defined.
+                            (bestFit || (bestFit = {}))[loc] = msWaiting[loc];
+                        } else {
+                            //Mix in the properties of this locale together.
+                            //Split the locale into pieces.
+                            mixed = {};
+                            parts = loc.split("-");
+                            for (j = parts.length; j > 0; j--) {
+                                locPart = parts.slice(0, j).join("-");
+                                if (locPart !== "root" && bundle[locPart]) {
+                                    require.mixin(mixed, bundle[locPart]);
+                                }
+                            }
+                            if (bundle.root) {
+                                require.mixin(mixed, bundle.root);
+                            }
+
+                            context.defined[modulePrefix + "/" + loc + "/" + moduleSuffix] = mixed;
+                        }
+                    }
+                }
+
+                //Finally define the default locale. Wait to the end of the property
+                //loop above so that the default locale bundle has been properly mixed
+                //together.
+                context.defined[master] = context.defined[modulePrefix + "/" + defLoc + "/" + moduleSuffix];
+                
+                //Handle any best fit locale definitions.
+                if (bestFit) {
+                    for (loc in bestFit) {
+                        if (!(loc in empty)) {
+                            context.defined[modulePrefix + "/" + loc + "/" + moduleSuffix] = context.defined[modulePrefix + "/" + bestFit[loc] + "/" + moduleSuffix];
+                        }
+                    }
+                }
+            }
+        }
+    });
+}());
+/**
+ * @license RequireJS text Copyright (c) 2010, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+/*jslint regexp: false, nomen: false, plusplus: false */
+/*global require: false, XMLHttpRequest: false, ActiveXObject: false */
+
+
+(function () {
+    var progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
+        xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
+        bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im;
+
+    if (!require.textStrip) {
+        require.textStrip = function (text) {
+            //Strips <?xml ...?> declarations so that external SVG and XML
+            //documents can be added to a document without worry. Also, if the string
+            //is an HTML document, only the part inside the body tag is returned.
+            if (text) {
+                text = text.replace(xmlRegExp, "");
+                var matches = text.match(bodyRegExp);
+                if (matches) {
+                    text = matches[1];
+                }
+            } else {
+                text = "";
+            }
+            return text;
+        };
+    }
+
+    //Upgrade require to add some methods for XHR handling. But it could be that
+    //this require is used in a non-browser env, so detect for existing method
+    //before attaching one.
+    if (!require.getXhr) {
+        require.getXhr = function () {
+            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
+            var xhr, i, progId;
+            if (typeof XMLHttpRequest !== "undefined") {
+                return new XMLHttpRequest();
+            } else {
+                for (i = 0; i < 3; i++) {
+                    progId = progIds[i];
+                    try {
+                        xhr = new ActiveXObject(progId);
+                    } catch (e) {}
+
+                    if (xhr) {
+                        progIds = [progId];  // so faster next time
+                        break;
+                    }
+                }   
+            }
+
+            if (!xhr) {
+                throw new Error("require.getXhr(): XMLHttpRequest not available");
+            }
+
+            return xhr;
+        };
+    }
+    
+    if (!require.fetchText) {
+        require.fetchText = function (url, callback) {
+            var xhr = require.getXhr();
+            xhr.open('GET', url, true);
+            xhr.onreadystatechange = function (evt) {
+                //Do not explicitly handle errors, those should be
+                //visible via console output in the browser.
+                if (xhr.readyState === 4) {
+                    callback(xhr.responseText);
+                }
+            };
+            xhr.send(null);
+        };
+    }
+
+    require.plugin({
+        prefix: "text",
+
+        /**
+         * This callback is prefix-specific, only gets called for this prefix
+         */
+        require: function (name, deps, callback, context) {
+            //No-op, require never gets these text items, they are always
+            //a dependency, see load for the action.
+        },
+
+        /**
+         * Called when a new context is defined. Use this to store
+         * context-specific info on it.
+         */
+        newContext: function (context) {
+            require.mixin(context, {
+                text: {},
+                textWaiting: []
+            });
+        },
+
+        /**
+         * Called when a dependency needs to be loaded.
+         */
+        load: function (name, contextName) {
+            //Name has format: some.module!filext!strip!text
+            //The strip and text parts are optional.
+            //if strip is present, then that means only get the string contents
+            //inside a body tag in an HTML string. For XML/SVG content it means
+            //removing the <?xml ...?> declarations so the content can be inserted
+            //into the current doc without problems.
+            //If text is present, it is the actual text of the file.
+            var strip = false, text = null, key, url, index = name.indexOf("."),
+                modName = name.substring(0, index), fullKey,
+                ext = name.substring(index + 1, name.length),
+                context = require.s.contexts[contextName],
+                tWaitAry = context.textWaiting;
+
+            index = ext.indexOf("!");
+            if (index !== -1) {
+                //Pull off the strip arg.
+                strip = ext.substring(index + 1, ext.length);
+                ext = ext.substring(0, index);
+                index = strip.indexOf("!");
+                if (index !== -1 && strip.substring(0, index) === "strip") {
+                    //Pull off the text.
+                    text = strip.substring(index + 1, strip.length);
+                    strip = "strip";
+                } else if (strip !== "strip") {
+                    //strip is actually the inlined text.
+                    text = strip;
+                    strip = null;
+                }
+            }
+            key = modName + "!" + ext;
+            fullKey = strip ? key + "!" + strip : key;
+
+            //Store off text if it is available for the given key and be done.
+            if (text !== null && !context.text[key]) {
+                context.defined[name] = context.text[key] = text;
+                return;
+            }
+
+            //If text is not available, load it.
+            if (!context.text[key] && !context.textWaiting[key] && !context.textWaiting[fullKey]) {
+                //Keep track that the fullKey needs to be resolved, during the
+                //orderDeps stage.
+                if (!tWaitAry[fullKey]) {
+                    tWaitAry[fullKey] = tWaitAry[(tWaitAry.push({
+                        name: name,
+                        key: key,
+                        fullKey: fullKey,
+                        strip: !!strip
+                    }) - 1)];
+                }
+
+                //Load the text.
+                url = require.nameToUrl(modName, "." + ext, contextName);
+                context.loaded[name] = false;
+                require.fetchText(url, function (text) {
+                    context.text[key] = text;
+                    context.loaded[name] = true;
+                });
+            }
+        },
+
+        /**
+         * Called when the dependencies of a module are checked.
+         */
+        checkDeps: function (name, deps, context) {
+            //No-op, checkDeps never gets these text items, they are always
+            //a dependency, see load for the action.
+        },
+
+        /**
+         * Called to determine if a module is waiting to load.
+         */
+        isWaiting: function (context) {
+            return !!context.textWaiting.length;
+        },
+
+        /**
+         * Called when all modules have been loaded.
+         */
+        orderDeps: function (context) {
+            //Clear up state since further processing could
+            //add more things to fetch.
+            var i, dep, text, tWaitAry = context.textWaiting;
+            context.textWaiting = [];
+            for (i = 0; (dep = tWaitAry[i]); i++) {
+                text = context.text[dep.key];
+                context.defined[dep.name] = dep.strip ? require.textStrip(text) : text;
+            }
+        }
+    });
+}());
+/**
+ * @license RequireJS jsonp Copyright (c) 2010, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+/*jslint nomen: false, plusplus: false */
+/*global require: false, setTimeout: false */
+
+
+(function () {
+    var countId = 0;
+
+    //A place to hold callback functions
+    require._jsonp = {};
+
+    require.plugin({
+        prefix: "jsonp",
+
+        /**
+         * This callback is prefix-specific, only gets called for this prefix
+         */
+        require: function (name, deps, callback, context) {
+            //No-op, require never gets these jsonp items, they are always
+            //a dependency, see load for the action.
+        },
+
+        /**
+         * Called when a new context is defined. Use this to store
+         * context-specific info on it.
+         */
+        newContext: function (context) {
+            require.mixin(context, {
+                jsonpWaiting: []
+            });
+        },
+
+        /**
+         * Called when a dependency needs to be loaded.
+         */
+        load: function (name, contextName) {
+            //Name has format: some/url?param1=value1&callback=?
+            //where the last question mark indicates where the jsonp callback
+            //function name needs to go.
+            var index = name.indexOf("?"),
+                url = name.substring(0, index),
+                params = name.substring(index + 1, name.length),
+                context = require.s.contexts[contextName],
+                data = {
+                    name: name
+                },
+                funcName = "f" + (countId++),
+                head = require.s.head,
+                node = head.ownerDocument.createElement("script");
+
+            //Create JSONP callback function
+            require._jsonp[funcName] = function (value) {
+                data.value = value;
+                context.loaded[name] = true;
+                //Use a setTimeout for cleanup because some older IE versions vomit
+                //if removing a script node while it is being evaluated.
+                setTimeout(function () {
+                    head.removeChild(node);
+                    delete require._jsonp[funcName];
+                }, 15);
+            };
+
+            //Hold on to the data for later dependency resolution in orderDeps.
+            context.jsonpWaiting.push(data);
+
+            //Build up the full JSONP URL
+            url = require.nameToUrl(url, "?", contextName);
+            //nameToUrl call may or may not have placed an ending ? on the URL,
+            //be sure there is one and add the rest of the params.
+            url += (url.indexOf("?") === -1 ? "?" : "") + params.replace("?", "require._jsonp." + funcName);
+
+            context.loaded[name] = false;
+            node.type = "text/javascript";
+            node.charset = "utf-8";
+            node.src = url;
+
+            //Use async so Gecko does not block on executing the script if something
+            //like a long-polling comet tag is being run first. Gecko likes
+            //to evaluate scripts in DOM order, even for dynamic scripts.
+            //It will fetch them async, but only evaluate the contents in DOM
+            //order, so a long-polling script tag can delay execution of scripts
+            //after it. But telling Gecko we expect async gets us the behavior
+            //we want -- execute it whenever it is finished downloading. Only
+            //Helps Firefox 3.6+
+            node.async = true;
+
+            head.appendChild(node);
+        },
+
+        /**
+         * Called when the dependencies of a module are checked.
+         */
+        checkDeps: function (name, deps, context) {
+            //No-op, checkDeps never gets these jsonp items, they are always
+            //a dependency, see load for the action.
+        },
+
+        /**
+         * Called to determine if a module is waiting to load.
+         */
+        isWaiting: function (context) {
+            return !!context.jsonpWaiting.length;
+        },
+
+        /**
+         * Called when all modules have been loaded.
+         */
+        orderDeps: function (context) {
+            //Clear up state since further processing could
+            //add more things to fetch.
+            var i, dep, waitAry = context.jsonpWaiting;
+            context.jsonpWaiting = [];
+            for (i = 0; (dep = waitAry[i]); i++) {
+                context.defined[dep.name] = dep.value;
+            }
+        }
+    });
+}());
+/**
+ * @license RequireJS order Copyright (c) 2010, The Dojo Foundation All Rights Reserved.
+ * Available via the MIT or new BSD license.
+ * see: http://github.com/jrburke/requirejs for details
+ */
+/*jslint nomen: false, plusplus: false */
+/*global require: false, window: false, document: false, setTimeout: false */
+
+
+(function () {
+    //Sadly necessary browser inference due to differences in the way
+    //that browsers load and execute dynamically inserted javascript
+    //and whether the script/cache method works.
+    //Currently, Gecko and Opera do not load/fire onload for scripts with
+    //type="script/cache" but they execute injected scripts in order
+    //unless the 'async' flag is present.
+    var supportsInOrderExecution = ((window.opera && Object.prototype.toString.call(window.opera) === "[object Opera]") ||
+                               //If Firefox 2 does not have to be supported, then
+                               //a better check may be:
+                               //('mozIsLocallyAvailable' in window.navigator)
+                               ("MozAppearance" in document.documentElement.style)),
+        readyRegExp = /^(complete|loaded)$/;
+
+    //Callback used by the type="script/cache" callback that indicates a script
+    //has finished downloading.
+    function scriptCacheCallback(evt) {
+        var node = evt.currentTarget || evt.srcElement, i,
+            context, contextName, moduleName, waiting, cached;
+
+        if (evt.type === "load" || readyRegExp.test(node.readyState)) {
+            //Pull out the name of the module and the context.
+            contextName = node.getAttribute("data-requirecontext");
+            moduleName = node.getAttribute("data-requiremodule");
+            context = require.s.contexts[contextName];
+            waiting = context.orderWaiting;
+            cached = context.orderCached;
+
+            //Mark this cache request as loaded
+            cached[moduleName] = true;
+
+            //Find out how many ordered modules have loaded
+            for (i = 0; cached[waiting[i]]; i++) {}
+            if (i > 0) {
+                require(waiting.splice(0, i), contextName);
+            }
+
+            //If no other order cache items are in the queue, do some cleanup.
+            if (!waiting.length) {
+                context.orderCached = {};
+            }
+
+            //Remove this script tag from the DOM
+            //Use a setTimeout for cleanup because some older IE versions vomit
+            //if removing a script node while it is being evaluated.
+            setTimeout(function () {
+                node.parentNode.removeChild(node);
+            }, 15);
+        }
+    }
+
+    require.plugin({
+        prefix: "order",
+
+        /**
+         * This callback is prefix-specific, only gets called for this prefix
+         */
+        require: function (name, deps, callback, context) {
+            //No-op, require never gets these order items, they are always
+            //a dependency, see load for the action.
+        },
+
+        /**
+         * Called when a new context is defined. Use this to store
+         * context-specific info on it.
+         */
+        newContext: function (context) {
+            require.mixin(context, {
+                orderWaiting: [],
+                orderCached: {}
+            });
+        },
+
+        /**
+         * Called when a dependency needs to be loaded.
+         */
+        load: function (name, contextName) {
+            var context = require.s.contexts[contextName],
+                url = require.nameToUrl(name, null, contextName);
+
+            //Make sure the async attribute is not set for any pathway involving
+            //this script.
+            require.s.skipAsync[url] = true;
+            if (supportsInOrderExecution) {
+                //Just a normal script tag append, but without async attribute
+                //on the script.
+                require([name], contextName);
+            } else {
+                //Credit to LABjs author Kyle Simpson for finding that scripts
+                //with type="script/cache" allow scripts to be downloaded into
+                //browser cache but not executed. Use that
+                //so that subsequent addition of a real type="text/javascript"
+                //tag will cause the scripts to be executed immediately in the
+                //correct order.
+                context.orderWaiting.push(name);
+                context.loaded[name] = false;
+                require.attach(url, contextName, name, scriptCacheCallback, "script/cache");
+            }
+        },
+
+        /**
+         * Called when the dependencies of a module are checked.
+         */
+        checkDeps: function (name, deps, context) {
+            //No-op, checkDeps never gets these order items, they are always
+            //a dependency, see load for the action.
+        },
+
+        /**
+         * Called to determine if a module is waiting to load.
+         */
+        isWaiting: function (context) {
+            return !!context.orderWaiting.length;
+        },
+
+        /**
+         * Called when all modules have been loaded. Not needed for this plugin.
+         * State is reset as part of scriptCacheCallback. 
+         */
+        orderDeps: function (context) {
+        }
+    });
+}());
+
+//Target build file for a require.js that has all of require's functionality,
+//and includes specific plugins: i18n and text.
